## 题目地址(989. 数组形式的整数加法)

https://leetcode-cn.com/problems/add-to-array-form-of-integer/

## 题目描述

```
对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。

给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。

 

示例 1：

输入：A = [1,2,0,0], K = 34
输出：[1,2,3,4]
解释：1200 + 34 = 1234


示例 2：

输入：A = [2,7,4], K = 181
输出：[4,5,5]
解释：274 + 181 = 455


示例 3：

输入：A = [2,1,5], K = 806
输出：[1,0,2,1]
解释：215 + 806 = 1021


示例 4：

输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1
输出：[1,0,0,0,0,0,0,0,0,0,0]
解释：9999999999 + 1 = 10000000000


 

提示：

1 <= A.length <= 10000
0 <= A[i] <= 9
0 <= K <= 10000
如果 A.length > 1，那么 A[0] != 0
```

## 前置知识

- 数组、数组遍历

## 思路

加法主要就是判断进位的问题。相加的选择，我们可以从低位往高位相加

1. 如果没有产生进位，那什么情况才停止相加呢？比如 $123+23=146$和 $123+1234=1367$
2. 如果产生进位，但没有发生数组越界的情况，比如$123+37=160 $和$123+1137=1260$
3. 如果产生进位，但发生了数组越界呢？比如$999+1=1000$

---

第一种情况：当我们低位往高位相加的时候，`k=0`的时候或者`遍历完num`，我们就停止了相加。

第二种情况：就在第一种情况的基础上，在中间增加个进位的处理，其停止的情况还是`k=0`的时候或者`遍历完num`。

第三种情况：就在第二种情况的基础上，最后增加高位还有进位的处理情况。而停止还是一样的

因此总结一下：

来自题解区的一位大佬

```java
<公式>
当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10

<加法模板>    
while ( A 没完 || B 没完)
    A 的当前位
    B 的当前位

    和 = A 的当前位 + B 的当前位 + 进位carry

    当前位 = 和 % 10;
    进位 = 和 / 10;

判断还有进位吗
```



## 代码

- 语言支持：Java

Java Code1:

```java
class Solution {
    public List<Integer> addToArrayForm(int[] num, int k) {
        //从低位往高位相加
        int n = num.length;
        List<Integer> res = new ArrayList<>();
        //遍历num，但k也在发生变化
        for(int i = n-1;i >= 0; i--){
            int sum = num[i] + k%10;
            k /=10;
            if(sum >= 10){
                k++;
                sum -= 10;
            }
            res.add(sum);
        }
        //如果num的位数>k的位数，此时的k是为0或者是最高位的进位
        for (; k > 0; k /= 10) {
            res.add(k % 10);
        }
        Collections.reverse(res);
        return res;
    }
}
```

**复杂度分析**

令 n 为数组长度。

- 时间复杂度：$O(n)$

Java Code2:

```java
class Solution {
    public List<Integer> addToArrayForm(int[] num, int k){
        //当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10
        int n = num.length;
        List<Integer> res = new ArrayList<>();
        int carry =0, sum =0,index = n-1;
        while(index >=0 || k!=0){
            // num的当前位
            int x = index >=0 ? num[index] : 0;
            // K的当前位
            int y = k != 0 ? k%10 : 0;

            sum = x + y + carry;
            carry = sum / 10;
            k = k / 10;
            index --;
            res.add(sum % 10);
        }
        if (carry != 0){
            res.add(carry);
        }
        Collections.reverse(res);
        return res;
    }
}
```

**复杂度分析**

令 n 为数组长度。

- 时间复杂度：$O(n)$

此外还有一道简单的题目：题目地址[66. 加一](https://leetcode-cn.com/problems/plus-one/)